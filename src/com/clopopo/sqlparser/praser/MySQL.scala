package com.clopopo.sqlparser.praser

object Keyword extends Enumeration {
  val SELECT, ALL, DISTINCT, DISTINCTROW, AS, FROM, WHERE, DIV, MOD, OR, AND, INTERVAL,INNER,CROSS,LEFT,RIGHT,JOIN,OUTER,NATURAL = Value
  type Keyword = Value
}

object Function extends Enumeration {
  val ABS, ACOS, ASIN, ATAN2, ATAN, CEIL, CEILING, CONV, COS, COT, CRC32, DEGREES, EXP, FLOOR, LN, LOG10, LOG2, LOG, MOD, PI, POW, POWER, RADIANS, RAND, ROUND, SIGN, SIN, SQRT, TAN, TRUNCATE, // char functions
  ASCII_SYM, BIN, BIT_LENGTH, CHAR_LENGTH, CHAR, CONCAT_WS, CONCAT, ELT, EXPORT_SET, FIELD, FIND_IN_SET, FORMAT, FROM_BASE64, HEX, INSERT, INSTR, LEFT, LENGTH, LOCATE, LOWER, LPAD, LTRIM, MID, OCT, ORD, QUOTE, REPEAT, REPLACE, REVERSE, RIGHT, RPAD, RTRIM, SOUNDEX, SPACE, STRCMP, SUBSTRING_INDEX, SUBSTRING, TO_BASE64, TRIM, UNHEX, UPPER, WEIGHT_STRING, // time_functions
  ADDDATE, ADDTIME, CONVERT_TZ, CURDATE, CURTIME, DATE_ADD, DATE_FORMAT, DATE_SUB, DATE_SYM, DATEDIFF, DAYNAME, DAYOFMONTH, DAYOFWEEK, DAYOFYEAR, EXTRACT, FROM_DAYS, FROM_UNIXTIME, GET_FORMAT, HOUR, LAST_DAY, MAKEDATE, MAKETIME, MICROSECOND, MINUTE, MONTH, MONTHNAME, NOW, PERIOD_ADD, PERIOD_DIFF, QUARTER, SEC_TO_TIME, SECOND, STR_TO_DATE, SUBTIME, SYSDATE, TIME_FORMAT, TIME_TO_SEC, TIME_SYM, TIMEDIFF, TIMESTAMP, TIMESTAMPADD, TIMESTAMPDIFF, TO_DAYS, TO_SECONDS, UNIX_TIMESTAMP, UTC_DATE, UTC_TIME, UTC_TIMESTAMP, WEEK, WEEKDAY, WEEKOFYEAR, YEAR, YEARWEEK, // other_functions
  MAKE_SET, LOAD_FILE, IF, IFNULL, AES_ENCRYPT, AES_DECRYPT, DECODE, ENCODE, DES_DECRYPT, DES_ENCRYPT, ENCRYPT, MD5, OLD_PASSWORD, PASSWORD, BENCHMARK, CHARSET, COERCIBILITY, COLLATION, CONNECTION_ID, CURRENT_USER, DATABASE, SCHEMA, USER, SESSION_USER, SYSTEM_USER, VERSION_SYM, FOUND_ROWS, LAST_INSERT_ID, DEFAULT, GET_LOCK, RELEASE_LOCK, IS_FREE_LOCK, IS_USED_LOCK, MASTER_POS_WAIT, INET_ATON, INET_NTOA, NAME_CONST, SLEEP, UUID, VALUES, // group_functions
  AVG, COUNT, MAX_SYM, MIN_SYM, SUM, BIT_AND, BIT_OR, BIT_XOR, GROUP_CONCAT, STD, STDDEV, STDDEV_POP, STDDEV_SAMP, VAR_POP, VAR_SAMP, VARIANCE = Value
  private val functions = Function.values.map(v => v.toString())

  def isFunction(name: String): Boolean = functions.contains(name.toUpperCase)

  def getFunction(name: String): Option[Value] = {
    try {
      Some(Function.withName(name.toUpperCase))
    } catch {
      case e: Exception => None
    }
  }
}